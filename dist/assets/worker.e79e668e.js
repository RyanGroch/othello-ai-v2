var z=Object.defineProperty;var W=(m,v,h)=>v in m?z(m,v,{enumerable:!0,configurable:!0,writable:!0,value:h}):m[v]=h;var p=(m,v,h)=>(W(m,typeof v!="symbol"?v+"":v,h),h);(function(){"use strict";const m=[0,1,2,3,4,5,6,7],v=[1,2,3,4,5,6,7,8],h=["A","B","C","D","E","F","G","H"],b=[[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[-1,1]],O=new Map(m.map(e=>[h[e],e])),V=e=>!!v.filter(r=>r===e).length,B=e=>!!h.filter(r=>e===r).length,f=e=>!!m.filter(r=>r===e).length,N=(e,r)=>{const t=8-e;if(!V(t))throw new Error("Unexpected type");return`${h[r]}${t}`},C=e=>{const r=e.split(""),[t,s]=[r[0],Number(r[1])],n=8-s;if(!B(t)||!f(n))throw new Error("Unexpected type");const a=O.get(t);if(a===void 0)throw new Error("Unexpected type");return[n,a]},Y=[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,2,1,0,0,0],[0,0,0,1,2,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]];class T{constructor(r=1,t=Y,s=!1){p(this,"blackTiles");p(this,"whiteTiles");p(this,"validMoves");p(this,"gameOver");this.playerToMove=r,this.board=t,this.prevMovePassed=s,[this.blackTiles,this.whiteTiles]=this.board.reduce((n,a)=>a.reduce((o,l)=>[o[0]+ +(l===1),o[1]+ +(l===2)],n),[0,0]),this.validMoves=this.calcValidMoves(),this.gameOver=Boolean(!this.validMoves.length&&this.prevMovePassed)}passTurn(){if(this.validMoves.length||this.gameOver)return this;const r=this.playerToMove===1?2:1;return new T(r,this.board,!0)}playMove(r){if(this.gameOver||!this.validMoves.includes(r))return this;const[t,s]=C(r),n=this.playerToMove===1?2:1,a=b.reduce((l,c)=>[...l,...this.parseTiles(t,s,c)],[]),o=this.board.map((l,c)=>{if(!f(c))throw new Error("Row is an incorrect size.");return l.map((u,i)=>{if(!f(i))throw new Error("Column is an incorrect size.");return t===c&&s===i||a.includes(N(c,i))?this.playerToMove:u})});return new T(n,o)}calcValidMoves(r=!0){const t=[];return this.board.forEach((s,n)=>{if(!f(n))throw new Error("Row is an incorrect size.");s.forEach((a,o)=>{if(!f(o))throw new Error("Column is an incorrect size.");if(a===0){for(const l of b)if(this.parseTiles(n,o,l,r).length){t.push(N(n,o));break}}})}),t}parseTiles(r,t,s,n=!0){const a=[],[o,l]=s,c=n?this.playerToMove:3-this.playerToMove;let u=!1;for(;;){if(r+=l,t+=o,!f(r)||!f(t)||this.board[r][t]===0||this.board[r][t]===c&&!u)return[];if(u=!0,this.board[r][t]===c)return a;a.push(N(r,t))}}}const F=[[0,0],[0,7],[7,0],[7,7]],d=(e,r)=>{const t=r===1?e.blackTiles:e.whiteTiles,s=r===2?e.blackTiles:e.whiteTiles;return 100*((t-s)/(t+s))},E=e=>{const r=e.calcValidMoves(!1).length,t=e.validMoves.length;return 100*((t-r)/(t+r)||0)},w=(e,r)=>{const t=3-r;let s=0,n=0;for(const[a,o]of F)e.board[a][o]===r?s++:e.board[a][o]===t&&n++;return 100*((s-n)/(s+n)||0)},g=e=>(64-(e.blackTiles+e.whiteTiles))%2===0?-1:1,R=e=>{const r=e.playerToMove;return 3*E(e)+d(e,r)+3*w(e,r)},D=e=>{const r=e.blackTiles+e.whiteTiles;return r<20?0:r<58?1:2},_=e=>{const r=e.playerToMove,t=D(e);if(e.gameOver)return d(e,r);switch(t){case 0:return 9*w(e,r)+E(e);case 1:return 5*w(e,r)+3*E(e)+g(e)+d(e,r);case 2:return 3*w(e,r)+1*E(e)+3*g(e)+3*d(e,r);default:throw new Error("Invalid game phase.")}},A=e=>{const r=e.playerToMove;return d(e,r)},H=e=>Math.random(),L=(e,r,t)=>{if(e.playerToMove===0)throw new Error("Player to move isn't specified");const s=t(e),n=r?-1:1,a=n*s;return Number.isNaN(s)?n*Number.POSITIVE_INFINITY:a},y=(e,r,t,s,n,a,o,l)=>{if(!l||o(l))return 0;if(r===0||e.gameOver)return L(e,!n,a);if(!e.validMoves.length)return y(e.passTurn(),r,t,s,!n,a,o,l);if(n){let c=Number.NEGATIVE_INFINITY;for(const u of e.validMoves){const i=y(e.playMove(u),r-1,t,s,!1,a,o,l);if(c=Math.max(c,i),t=Math.max(t,i),s<=t)break}return c}else{let c=Number.POSITIVE_INFINITY;for(const u of e.validMoves){const i=y(e.playMove(u),r-1,t,s,!0,a,o,l);if(c=Math.min(c,i),s=Math.min(s,i),s<=t)break}return c}};var M=(e=>(e.Human="Human",e.Basic="Basic",e.Dynamic="Dynamic",e.Greedy="Greedy",e.Random="Random",e))(M||{});function I(e){let r=new XMLHttpRequest;r.open("GET",e,!1);try{r.send(null)}catch{return!0}return!1}const S=e=>{switch(e){case M.Basic:return R;case M.Greedy:return A;case M.Dynamic:return _;case M.Random:return H;default:return null}},U=e=>{let r=[],t=Number.NEGATIVE_INFINITY;return e.forEach((s,n)=>{s>t?(t=s,r=[n]):s===t&&r.push(n)}),r};onmessage=e=>{const{position:r,players:t,stopToken:s}=e.data,n=r.playerToMove-1,a=new T(r.playerToMove,r.board,r.prevMovePassed),o=t.evaluators[n],l=t.depth[n],c=S(o);if(!c)throw new Error("Invalid player type.");const u=a.validMoves.map(k=>y(a.playMove(k),l,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,!1,c,I,s)),i=U(u),G=i[Math.floor(Math.random()*i.length)];I(s)||postMessage(G)}})();
